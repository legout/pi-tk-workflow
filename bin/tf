#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIG_HELPER="$ROOT_DIR/scripts/tf_config.py"

usage() {
  cat <<'EOF'
Ticketflow CLI

Usage:
  ./bin/irf setup [--global|--project <path>]
  ./bin/irf sync [--global|--project <path>]
  ./bin/irf doctor [--global|--project <path>]
  ./bin/irf backlog-ls [topic-id-or-path] [--global|--project <path>]
  ./bin/irf track <path> [--file <files_changed_path>]
  ./bin/irf ralph <subcommand> [options]

Commands:
  setup       Interactive install + optional dependencies + MCP config
  sync        Sync agent models from workflow config into agent files
  doctor      Preflight checks for tk/pi/extensions/checkers
  backlog-ls  List backlog status and tickets for seed/baseline topics
  track       Append file paths to files_changed.txt (deduped)
  ralph       Ralph loop management (see below)
  agentsmd    AGENTS.md management (init, validate, fix, status)

Ralph Subcommands:
  ralph init     Create .pi/ralph/ directory structure
  ralph status   Show current loop state and statistics
  ralph reset    Clear progress (optionally keep lessons)
  ralph lessons  Show or prune lessons learned

Agentsmd Subcommands:
  agentsmd init [path]     Create minimal AGENTS.md (defaults: uv, current dir)
  agentsmd status [path]   Show AGENTS.md overview and recommendations
  agentsmd validate [path] Check for bloat, stale paths, contradictions
  agentsmd fix [path]      Auto-fix common issues (backup created)

Options:
  --global                 Install/sync in ~/.pi/agent (default for setup)
  --project <path>         Install/sync in <path>/.pi
  --file <path>            Output files_changed.txt path (track only)
  --keep-lessons           Keep lessons when resetting (ralph reset only)
  --help                   Show this help

Environment (for setup MCP):
  ZAI_API_KEY, CONTEXT7_API_KEY, EXA_API_KEY

Environment (for track):
  TF_FILES_CHANGED, TF_CHAIN_DIR
EOF
}

if [ "$#" -lt 1 ]; then
  usage
  exit 1
fi

COMMAND="$1"
shift

TARGET_BASE=""
SCOPE_FLAG=""
TRACK_FILE=""
ARGS=()
IS_GLOBAL=false

while [ "$#" -gt 0 ]; do
  case "$1" in
    --global)
      TARGET_BASE="$HOME/.pi/agent"
      SCOPE_FLAG=""
      IS_GLOBAL=true
      shift
      ;;
    --project)
      if [ -z "${2:-}" ]; then
        echo "Missing path after --project" >&2
        exit 1
      fi
      TARGET_BASE="$2/.pi"
      SCOPE_FLAG="-l"
      IS_GLOBAL=false
      shift 2
      ;;
    --file)
      if [ "$COMMAND" != "track" ]; then
        echo "--file is only valid with 'track'" >&2
        usage
        exit 1
      fi
      if [ -z "${2:-}" ]; then
        echo "Missing path after --file" >&2
        exit 1
      fi
      TRACK_FILE="$2"
      shift 2
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    --)
      shift
      while [ "$#" -gt 0 ]; do
        ARGS+=("$1")
        shift
      done
      ;;
    -* )
      # For ralph command, pass options through to subcommand
      if [ "$COMMAND" = "ralph" ]; then
        ARGS+=("$1")
        shift
      else
        echo "Unknown option: $1" >&2
        usage
        exit 1
      fi
      ;;
    *)
      ARGS+=("$1")
      shift
      ;;
  esac
 done

if [ -z "$TARGET_BASE" ] && [ "$COMMAND" != "track" ]; then
  if [ "$COMMAND" = "setup" ]; then
    TARGET_BASE="$HOME/.pi/agent"
    IS_GLOBAL=true
  else
    # sync/doctor default: prefer project if .pi exists in cwd
    if [ -d ".pi" ]; then
      TARGET_BASE="$(pwd)/.pi"
      SCOPE_FLAG="-l"
      IS_GLOBAL=false
    else
      TARGET_BASE="$HOME/.pi/agent"
      IS_GLOBAL=true
    fi
  fi
fi

install_files() {
  local manifest="$ROOT_DIR/config/install-manifest.txt"

  if [ ! -f "$manifest" ]; then
    echo "Install manifest not found: $manifest" >&2
    exit 1
  fi

  local count=0
  while IFS= read -r line || [ -n "$line" ]; do
    line="$(printf '%s' "$line" | sed -e 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    if [ -z "$line" ] || [[ "$line" == \#* ]]; then
      continue
    fi
    if [ ! -f "$ROOT_DIR/$line" ]; then
      echo "Missing install file: $ROOT_DIR/$line" >&2
      exit 1
    fi
    mkdir -p "$TARGET_BASE/$(dirname "$line")"
    cp "$ROOT_DIR/$line" "$TARGET_BASE/$line"
    count=$((count + 1))
  done < "$manifest"

  echo "Installed Ticketflow workflow to: $TARGET_BASE"
  echo "Installed files: $count"
}

install_extensions() {
  local install_deps="$1"
  local install_optional="$2"
  if ! command -v pi >/dev/null 2>&1; then
    echo "pi not found in PATH; skipping extension installs." >&2
    return 0
  fi
  if [ "$install_deps" = "true" ]; then
    pi install $SCOPE_FLAG npm:pi-subagents
    pi install $SCOPE_FLAG npm:pi-model-switch
    pi install $SCOPE_FLAG npm:pi-prompt-template-model
  fi
  if [ "$install_optional" = "true" ]; then
    pi install $SCOPE_FLAG npm:pi-review-loop
    pi install $SCOPE_FLAG npm:pi-mcp-adapter
  fi
}

is_uv_project() {
  if [ -f "uv.lock" ]; then
    return 0
  fi
  if [ -f "pyproject.toml" ] && grep -q "^\[tool\.uv\]" pyproject.toml; then
    return 0
  fi
  return 1
}

resolve_python_cmd() {
  PYTHON_CMD=()
  if command -v python3 >/dev/null 2>&1; then
    PYTHON_CMD=(python3)
    return 0
  fi
  if command -v python >/dev/null 2>&1; then
    PYTHON_CMD=(python)
    return 0
  fi
  if command -v uv >/dev/null 2>&1 && is_uv_project; then
    PYTHON_CMD=(uv run python)
    return 0
  fi
  return 1
}

configure_mcp() {
  local mcp_file="$TARGET_BASE/mcp.json"
  local zai_key="$1"
  local ctx7_key="$2"
  local exa_key="$3"

  local python_cmd=()
  if resolve_python_cmd; then
    python_cmd=("${PYTHON_CMD[@]}")
  else
    echo "Python not found; skipping MCP config." >&2
    return 0
  fi

  local ignore_project="false"
  if [ "$IS_GLOBAL" = true ]; then
    ignore_project="true"
  fi

  local args=(
    "$CONFIG_HELPER"
    configure-mcp
    --mcp-file "$mcp_file"
    --base "$TARGET_BASE"
    --zai-key "$zai_key"
    --ctx7-key "$ctx7_key"
    --exa-key "$exa_key"
  )

  if [ "$ignore_project" = "true" ]; then
    args+=(--ignore-project)
  fi

  "${python_cmd[@]}" "${args[@]}"
}

track_file() {
  local tracked_path="${1:-}"
  if [ -z "$tracked_path" ]; then
    echo "Usage: ./bin/irf track <path> [--file <files_changed_path>]" >&2
    exit 1
  fi

  local files_changed="$TRACK_FILE"
  if [ -z "$files_changed" ]; then
    if [ -n "${TF_FILES_CHANGED:-}" ]; then
      files_changed="$TF_FILES_CHANGED"
    elif [ -n "${TF_CHAIN_DIR:-}" ]; then
      files_changed="$TF_CHAIN_DIR/files_changed.txt"
    else
      files_changed="$(pwd)/files_changed.txt"
    fi
  fi

  if [[ "$files_changed" != /* ]]; then
    files_changed="$(pwd)/$files_changed"
  fi

  if [[ "$tracked_path" != /* ]]; then
    tracked_path="$(pwd)/$tracked_path"
  fi

  mkdir -p "$(dirname "$files_changed")"
  touch "$files_changed"

  if ! grep -Fxq "$tracked_path" "$files_changed"; then
    echo "$tracked_path" >> "$files_changed"
  fi

  echo "Tracked: $tracked_path"
}

doctor() {
  local failed=0

  echo "Ticketflow doctor"

  check_cmd() {
    local name="$1"
    if command -v "$name" >/dev/null 2>&1; then
      echo "[ok] $name"
    else
      echo "[missing] $name"
      failed=1
    fi
  }

  check_extension() {
    local name="$1"
    local global_path="$HOME/.pi/agent/extensions/$name"
    local project_path=""
    if [[ "$TARGET_BASE" == */.pi ]]; then
      project_path="$TARGET_BASE/extensions/$name"
    fi

    if [ -d "$global_path" ] || { [ -n "$project_path" ] && [ -d "$project_path" ]; }; then
      if [ -n "$project_path" ] && [ -d "$project_path" ]; then
        echo "[ok] extension $name (project)"
      else
        echo "[ok] extension $name (global)"
      fi
    else
      echo "[missing] extension $name"
      failed=1
    fi
  }

  check_cmd "tk"
  check_cmd "pi"

  check_extension "pi-subagents"
  check_extension "pi-model-switch"
  check_extension "pi-prompt-template-model"

  local python_cmd=()
  if resolve_python_cmd; then
    python_cmd=("${PYTHON_CMD[@]}")
    local ignore_project="false"
    if [ "$IS_GLOBAL" = true ]; then
      ignore_project="true"
    fi

    local cmds
    local args=("$CONFIG_HELPER" checker-tools --base "$TARGET_BASE")
    if [ "$ignore_project" = "true" ]; then
      args+=(--ignore-project)
    fi
    cmds=$("${python_cmd[@]}" "${args[@]}")

    if [ -n "$cmds" ]; then
      echo "Checker tools:"
      while IFS= read -r cmd; do
        [ -z "$cmd" ] && continue
        check_cmd "$cmd"
      done <<< "$cmds"
    else
      echo "[info] No checkers configured"
    fi
  else
    echo "[missing] python (required to read checkers config)"
    failed=1
  fi

  if [ "$failed" -ne 0 ]; then
    echo "Ticketflow doctor: failed"
    exit 1
  fi

  echo "Ticketflow doctor: OK"
}

# =============================================================================
# Ralph Loop Management
# =============================================================================

RALPH_DIR=".pi/ralph"

ralph_usage() {
  cat <<'EOF'
Ralph Loop Management

Usage:
  ./bin/irf ralph init         Create .pi/ralph/ directory structure
  ./bin/irf ralph status       Show current loop state and statistics
  ./bin/irf ralph reset        Clear progress (use --keep-lessons to preserve lessons)
  ./bin/irf ralph lessons      Show lessons learned
  ./bin/irf ralph lessons prune [N]  Keep only last N lessons (default: 20)

The Ralph loop itself is started via Pi prompt:
  /ralph-start [--max-iterations N]

Files:
  .pi/ralph/AGENTS.md    Lessons learned (read by implementer)
  .pi/ralph/progress.md  Loop state and ticket history
  .pi/ralph/config.json  Loop configuration
EOF
}

ralph_init() {
  echo "Initializing Ralph loop directory..."
  
  mkdir -p "$RALPH_DIR"
  
  # Create AGENTS.md if not exists
  if [ ! -f "$RALPH_DIR/AGENTS.md" ]; then
    cat > "$RALPH_DIR/AGENTS.md" <<'AGENTS_EOF'
# Ralph Loop: Lessons Learned

This file contains lessons learned during autonomous ticket processing.
It is read by the implementer at the start of each iteration for re-anchoring.

## How This Works

When running in a Ralph loop, the agent reads this file to:
- Apply discovered patterns and conventions
- Avoid known gotchas and pitfalls
- Reuse successful strategies

## Project Patterns

<!-- Discovered patterns and conventions go here -->

## Gotchas

<!-- Things that caused issues and how to avoid them -->

## Successful Strategies

<!-- Approaches that worked well -->

## Technical Debt Notes

<!-- Known issues to address later -->

---

<!-- Lessons are auto-appended below by the closer agent -->
AGENTS_EOF
    echo "Created $RALPH_DIR/AGENTS.md"
  else
    echo "Exists: $RALPH_DIR/AGENTS.md"
  fi
  
  # Create progress.md if not exists
  if [ ! -f "$RALPH_DIR/progress.md" ]; then
    cat > "$RALPH_DIR/progress.md" <<'PROGRESS_EOF'
# Ralph Loop Progress

## Current State

- Status: IDLE
- Current ticket: (none)
- Started: (not started)
- Last updated: (never)

## Statistics

- Tickets completed: 0
- Tickets failed: 0
- Total iterations: 0

## History

<!-- Auto-appended entries below -->
PROGRESS_EOF
    echo "Created $RALPH_DIR/progress.md"
  else
    echo "Exists: $RALPH_DIR/progress.md"
  fi
  
  # Create config.json if not exists
  if [ ! -f "$RALPH_DIR/config.json" ]; then
    cat > "$RALPH_DIR/config.json" <<'CONFIG_EOF'
{
  "maxIterations": 50,
  "maxIterationsPerTicket": 5,
  "ticketQuery": "tk ready | head -1 | awk '{print $1}'",
  "completionCheck": "tk ready | grep -q .",
  "sleepBetweenTickets": 5000,
  "sleepBetweenRetries": 10000,
  "workflow": "/irf",
  "workflowFlags": "--auto",
  "includeKnowledgeBase": true,
  "includePlanningDocs": true,
  "promiseOnComplete": true,
  "lessonsMaxCount": 50
}
CONFIG_EOF
    echo "Created $RALPH_DIR/config.json"
  else
    echo "Exists: $RALPH_DIR/config.json"
  fi
  
  echo ""
  echo "Ralph loop initialized in $RALPH_DIR/"
  echo ""
  echo "Next steps:"
  echo "  1. Review $RALPH_DIR/config.json"
  echo "  2. Add initial patterns to $RALPH_DIR/AGENTS.md"
  echo "  3. Start the loop with: /ralph-start"
}

ralph_status() {
  if [ ! -d "$RALPH_DIR" ]; then
    echo "Ralph not initialized. Run: ./bin/irf ralph init"
    exit 1
  fi
  
  echo "=== Ralph Loop Status ==="
  echo ""
  
  # Read progress.md for status
  if [ -f "$RALPH_DIR/progress.md" ]; then
    # Extract current state section
    sed -n '/^## Current State/,/^## /p' "$RALPH_DIR/progress.md" | sed '$d'
    echo ""
    
    # Extract statistics section
    sed -n '/^## Statistics/,/^## /p' "$RALPH_DIR/progress.md" | sed '$d'
  else
    echo "Status: NOT INITIALIZED"
  fi
  
  echo ""
  echo "=== Ticket Queue ==="
  if command -v tk >/dev/null 2>&1; then
    local ready_count
    ready_count=$(tk ready 2>/dev/null | wc -l | tr -d ' ')
    echo "Ready tickets: $ready_count"
    if [ "$ready_count" -gt 0 ]; then
      echo ""
      tk ready 2>/dev/null | head -5 || echo "(unable to list tickets)"
    fi
  else
    echo "(tk not available)"
  fi
  
  echo ""
  echo "=== Lessons Learned ==="
  if [ -f "$RALPH_DIR/AGENTS.md" ]; then
    local lesson_count
    lesson_count=$(grep -c "^## Lesson from" "$RALPH_DIR/AGENTS.md" 2>/dev/null) || lesson_count=0
    echo "Total lessons: $lesson_count"
  else
    echo "No lessons file"
  fi
}

ralph_reset() {
  if [ ! -d "$RALPH_DIR" ]; then
    echo "Ralph not initialized. Run: ./bin/irf ralph init"
    exit 1
  fi
  
  local keep_lessons=false
  for arg in "$@"; do
    case "$arg" in
      --keep-lessons) keep_lessons=true ;;
    esac
  done
  
  echo "Resetting Ralph loop progress..."
  
  # Reset progress.md
  cat > "$RALPH_DIR/progress.md" <<'PROGRESS_EOF'
# Ralph Loop Progress

## Current State

- Status: IDLE
- Current ticket: (none)
- Started: (not started)
- Last updated: (never)

## Statistics

- Tickets completed: 0
- Tickets failed: 0
- Total iterations: 0

## History

<!-- Auto-appended entries below -->
PROGRESS_EOF
  echo "Reset: $RALPH_DIR/progress.md"
  
  if [ "$keep_lessons" = false ]; then
    # Reset AGENTS.md but keep structure
    cat > "$RALPH_DIR/AGENTS.md" <<'AGENTS_EOF'
# Ralph Loop: Lessons Learned

This file contains lessons learned during autonomous ticket processing.
It is read by the implementer at the start of each iteration for re-anchoring.

## How This Works

When running in a Ralph loop, the agent reads this file to:
- Apply discovered patterns and conventions
- Avoid known gotchas and pitfalls
- Reuse successful strategies

## Project Patterns

<!-- Discovered patterns and conventions go here -->

## Gotchas

<!-- Things that caused issues and how to avoid them -->

## Successful Strategies

<!-- Approaches that worked well -->

## Technical Debt Notes

<!-- Known issues to address later -->

---

<!-- Lessons are auto-appended below by the closer agent -->
AGENTS_EOF
    echo "Reset: $RALPH_DIR/AGENTS.md"
  else
    echo "Kept: $RALPH_DIR/AGENTS.md (--keep-lessons)"
  fi
  
  echo ""
  echo "Ralph loop reset complete."
}

ralph_lessons() {
  if [ ! -d "$RALPH_DIR" ]; then
    echo "Ralph not initialized. Run: ./bin/irf ralph init"
    exit 1
  fi
  
  local subcmd="${1:-show}"
  shift || true
  
  case "$subcmd" in
    show)
      if [ -f "$RALPH_DIR/AGENTS.md" ]; then
        cat "$RALPH_DIR/AGENTS.md"
      else
        echo "No lessons file found."
      fi
      ;;
    prune)
      local keep_count="${1:-20}"
      if [ ! -f "$RALPH_DIR/AGENTS.md" ]; then
        echo "No lessons file found."
        exit 1
      fi
      
      echo "Pruning lessons to keep last $keep_count..."
      
      # Use Python for reliable parsing
      local python_bin=""
      if command -v python3 >/dev/null 2>&1; then
        python_bin="python3"
      elif command -v python >/dev/null 2>&1; then
        python_bin="python"
      else
        echo "Python required for pruning." >&2
        exit 1
      fi
      
      RALPH_DIR="$RALPH_DIR" KEEP_COUNT="$keep_count" "$python_bin" - <<'PY'
import os
import re
from pathlib import Path

ralph_dir = Path(os.environ["RALPH_DIR"])
keep_count = int(os.environ.get("KEEP_COUNT", "20"))
agents_file = ralph_dir / "AGENTS.md"

content = agents_file.read_text(encoding="utf-8")

# Split at the separator line
parts = content.split("\n---\n", 1)
if len(parts) < 2:
    print("No lessons section found (no --- separator)")
    raise SystemExit(0)

header = parts[0]
lessons_section = parts[1]

# Find all lessons (start with "## Lesson from")
lesson_pattern = r"(## Lesson from .+?)(?=## Lesson from |\Z)"
lessons = re.findall(lesson_pattern, lessons_section, re.DOTALL)

total = len(lessons)
if total <= keep_count:
    print(f"Only {total} lessons found, keeping all.")
    raise SystemExit(0)

# Keep last N lessons
kept_lessons = lessons[-keep_count:]
removed = total - keep_count

new_content = header + "\n---\n\n" + "\n".join(kept_lessons)
agents_file.write_text(new_content, encoding="utf-8")

print(f"Pruned {removed} lessons, kept {keep_count}.")
PY
      ;;
    *)
      echo "Unknown lessons subcommand: $subcmd"
      echo "Usage: ./bin/irf ralph lessons [show|prune [N]]"
      exit 1
      ;;
  esac
}

ralph_cmd() {
  local subcmd="${1:-}"
  shift || true
  
  case "$subcmd" in
    init)
      ralph_init
      ;;
    status)
      ralph_status
      ;;
    reset)
      ralph_reset "$@"
      ;;
    lessons)
      ralph_lessons "$@"
      ;;
    ""|help|--help|-h)
      ralph_usage
      ;;
    *)
      echo "Unknown ralph subcommand: $subcmd" >&2
      ralph_usage
      exit 1
      ;;
  esac
}

# =============================================================================
# AGENTS.md Management
# =============================================================================

agentsmd_usage() {
  cat <<'EOF'
AGENTS.md Management

Usage:
  ./bin/irf agentsmd init [path]          Create minimal AGENTS.md
  ./bin/irf agentsmd status [path]        Show AGENTS.md overview
  ./bin/irf agentsmd validate [path]      Check for bloat, stale paths
  ./bin/irf agentsmd fix [path]           Auto-fix common issues

Options:
  [path]      Target directory (default: current directory)
              Creates AGENTS.md at [path]/AGENTS.md

Examples:
  ./bin/irf agentsmd init                 # Create AGENTS.md in current dir
  ./bin/irf agentsmd init ~/my-project    # Create in specific directory
  ./bin/irf agentsmd status               # Check current AGENTS.md
  ./bin/irf agentsmd validate             # Validate for issues
  ./bin/irf agentsmd fix                  # Auto-fix with backup
EOF
}

agentsmd_detect_package_manager() {
  local target_dir="$1"
  
  # Check for uv (preferred)
  if [ -f "$target_dir/uv.lock" ] || [ -f "$target_dir/pyproject.toml" ] && grep -q "\[tool.uv\]" "$target_dir/pyproject.toml" 2>/dev/null; then
    echo "uv"
    return 0
  fi
  
  # Check for other Python package managers
  if [ -f "$target_dir/poetry.lock" ]; then
    echo "poetry"
    return 0
  fi
  if [ -f "$target_dir/Pipfile" ]; then
    echo "pipenv"
    return 0
  fi
  if [ -f "$target_dir/requirements.txt" ]; then
    echo "pip"
    return 0
  fi
  if [ -f "$target_dir/setup.py" ] || [ -f "$target_dir/setup.cfg" ]; then
    echo "pip"
    return 0
  fi
  
  # Check for Node package managers
  if [ -f "$target_dir/pnpm-lock.yaml" ]; then
    echo "pnpm"
    return 0
  fi
  if [ -f "$target_dir/yarn.lock" ]; then
    echo "yarn"
    return 0
  fi
  if [ -f "$target_dir/package-lock.json" ]; then
    echo "npm"
    return 0
  fi
  if [ -f "$target_dir/bun.lockb" ]; then
    echo "bun"
    return 0
  fi
  
  # Check for other languages
  if [ -f "$target_dir/Cargo.toml" ]; then
    echo "cargo"
    return 0
  fi
  if [ -f "$target_dir/go.mod" ]; then
    echo "go"
    return 0
  fi
  if [ -f "$target_dir/Gemfile" ]; then
    echo "bundle"
    return 0
  fi
  
  # Default to uv for Python projects (check pyproject.toml without uv marker)
  if [ -f "$target_dir/pyproject.toml" ]; then
    echo "uv"
    return 0
  fi
  
  echo "unknown"
}

agentsmd_get_default_commands() {
  local pm="$1"
  case "$pm" in
    uv)
      echo "run: uv run python"
      echo "test: uv run pytest"
      echo "lint: uv run ruff check ."
      echo "format: uv run ruff format ."
      echo "typecheck: uv run mypy ."
      ;;
    poetry)
      echo "run: poetry run python"
      echo "test: poetry run pytest"
      echo "lint: poetry run ruff check ."
      ;;
    pipenv)
      echo "run: pipenv run python"
      echo "test: pipenv run pytest"
      ;;
    pip)
      echo "run: python"
      echo "test: pytest"
      ;;
    pnpm)
      echo "run: pnpm dev"
      echo "build: pnpm build"
      echo "test: pnpm test"
      echo "lint: pnpm lint"
      ;;
    npm)
      echo "run: npm run dev"
      echo "build: npm run build"
      echo "test: npm test"
      echo "lint: npm run lint"
      ;;
    yarn)
      echo "run: yarn dev"
      echo "build: yarn build"
      echo "test: yarn test"
      ;;
    bun)
      echo "run: bun run dev"
      echo "build: bun run build"
      echo "test: bun test"
      ;;
    cargo)
      echo "build: cargo build"
      echo "test: cargo test"
      echo "run: cargo run"
      ;;
    go)
      echo "build: go build"
      echo "test: go test"
      echo "run: go run ."
      ;;
    bundle)
      echo "run: bundle exec ruby"
      echo "test: bundle exec rspec"
      ;;
    *)
      echo ""
      ;;
  esac
}

agentsmd_init() {
  local target_dir="${1:-$(pwd)}"
  target_dir="$(cd "$target_dir" && pwd)"
  local agents_file="$target_dir/AGENTS.md"
  
  echo "Initializing AGENTS.md..."
  echo "Target directory: $target_dir"
  
  # Check if file already exists
  if [ -f "$agents_file" ]; then
    echo ""
    echo "⚠️  AGENTS.md already exists at:"
    echo "   $agents_file"
    echo ""
    read -r -p "Overwrite? (y/N) " yn
    case "$yn" in
      [Yy]*)
        mv "$agents_file" "$agents_file.backup.$(date +%Y%m%d%H%M%S)"
        echo "Backed up existing file."
        ;;
      *)
        echo "Cancelled."
        exit 0
        ;;
    esac
  fi
  
  # Detect package manager
  local pm
  pm=$(agentsmd_detect_package_manager "$target_dir")
  echo "Detected package manager: $pm"
  
  # Get project name from directory
  local project_name
  project_name=$(basename "$target_dir")
  
  # Interactive prompts
  echo ""
  read -r -p "Project name [$project_name]: " input_name
  project_name="${input_name:-$project_name}"
  
  echo ""
  read -r -p "One-sentence description: " description
  
  if [ -z "$description" ]; then
    description="A $project_name project."
  fi
  
  # Generate AGENTS.md content
  cat > "$agents_file" <<EOF
# $project_name

$description

## Quick Commands
EOF

  # Add commands based on package manager
  local cmds
  cmds=$(agentsmd_get_default_commands "$pm")
  if [ -n "$cmds" ]; then
    while IFS= read -r line; do
      if [ -n "$line" ]; then
        echo "- $line" >> "$agents_file"
      fi
    done <<< "$cmds"
  fi
  
  # Add package manager note
  case "$pm" in
    uv)
      echo "" >> "$agents_file"
      echo "This project uses \`uv\` for Python package management." >> "$agents_file"
      echo "See: https://docs.astral.sh/uv/" >> "$agents_file"
      ;;
    poetry)
      echo "" >> "$agents_file"
      echo "This project uses \`poetry\` for Python package management." >> "$agents_file"
      ;;
    pnpm)
      echo "" >> "$agents_file"
      echo "This project uses \`pnpm\` for Node.js package management." >> "$agents_file"
      ;;
  esac
  
  # Add conventions section
  cat >> "$agents_file" <<'EOF'

## Conventions

<!-- Add links to convention docs as needed: -->
<!-- - TypeScript: See [docs/TYPESCRIPT.md](./docs/TYPESCRIPT.md) -->
<!-- - Testing: See [docs/TESTING.md](./docs/TESTING.md) -->

## Notes

<!-- Project-specific notes for AI agents -->
EOF

  echo ""
  echo "✓ Created AGENTS.md at:"
  echo "  $agents_file"
  echo ""
  echo "File size: $(wc -c < "$agents_file") bytes"
  echo ""
  echo "Next steps:"
  echo "  1. Review and customize the description"
  echo "  2. Add convention docs to docs/ folder if needed"
  echo "  3. Run './bin/irf agentsmd validate' to check"
  
  # Offer to symlink CLAUDE.md for Claude Code users
  if [ ! -f "$target_dir/CLAUDE.md" ]; then
    echo ""
    read -r -p "Create CLAUDE.md symlink for Claude Code? (y/N) " yn
    case "$yn" in
      [Yy]*)
        ln -s AGENTS.md "$target_dir/CLAUDE.md"
        echo "Created CLAUDE.md → AGENTS.md symlink"
        ;;
    esac
  fi
}

agentsmd_status() {
  local target_dir="${1:-$(pwd)}"
  local agents_file="$target_dir/AGENTS.md"
  
  echo "=== AGENTS.md Status ==="
  echo ""
  
  if [ ! -f "$agents_file" ]; then
    echo "❌ No AGENTS.md found at: $agents_file"
    echo ""
    echo "Create one with:"
    echo "  ./bin/irf agentsmd init"
    exit 1
  fi
  
  local size
  size=$(wc -c < "$agents_file")
  local lines
  lines=$(wc -l < "$agents_file")
  
  echo "File: $agents_file"
  echo "Size: $size bytes"
  echo "Lines: $lines"
  echo ""
  
  # Size assessment
  if [ "$size" -lt 2048 ]; then
    echo "✓ Size: Good (under 2KB)"
  elif [ "$size" -lt 5120 ]; then
    echo "⚠️  Size: Moderate ($size bytes) - consider using progressive disclosure"
  else
    echo "❌ Size: Large ($size bytes) - recommend refactoring"
  fi
  
  # Check for CLAUDE.md symlink
  echo ""
  if [ -L "$target_dir/CLAUDE.md" ]; then
    echo "✓ CLAUDE.md symlink exists"
  elif [ -f "$target_dir/CLAUDE.md" ]; then
    echo "⚠️  CLAUDE.md exists (separate file, not symlinked)"
  else
    echo "○ CLAUDE.md not found (optional, for Claude Code users)"
  fi
  
  # Check for nested AGENTS.md files
  echo ""
  echo "Nested AGENTS.md files:"
  local found_nested=false
  while IFS= read -r -d '' file; do
    if [ "$file" != "$agents_file" ]; then
      echo "  - ${file#$target_dir/} ($(wc -c < "$file") bytes)"
      found_nested=true
    fi
  done < <(find "$target_dir" -name "AGENTS.md" -type f -print0 2>/dev/null)
  
  if [ "$found_nested" = false ]; then
    echo "  (none found)"
  fi
  
  # Quick content preview
  echo ""
  echo "=== Content Preview ==="
  head -20 "$agents_file"
  if [ "$lines" -gt 20 ]; then
    echo "... ($((lines - 20)) more lines)"
  fi
}

agentsmd_validate() {
  local target_dir="${1:-$(pwd)}"
  local agents_file="$target_dir/AGENTS.md"
  
  echo "=== AGENTS.md Validation ==="
  echo ""
  
  if [ ! -f "$agents_file" ]; then
    echo "❌ AGENTS.md not found at: $agents_file"
    exit 1
  fi
  
  local issues=0
  local warnings=0
  
  # Check file size
  local size
  size=$(wc -c < "$agents_file")
  echo "File size: $size bytes"
  
  if [ "$size" -gt 5120 ]; then
    echo "❌ File is large ($size bytes > 5KB). Consider progressive disclosure."
    ((issues++))
  elif [ "$size" -gt 2048 ]; then
    echo "⚠️  File is moderate size ($size bytes). Monitor for growth."
    ((warnings++))
  else
    echo "✓ File size is good"
  fi
  
  # Extract and check file paths (skip comments)
  echo ""
  echo "Checking referenced paths..."
  local paths
  paths=$(grep -v '^\s*<' "$agents_file" 2>/dev/null | grep -oE '\b(src|lib|docs|test|tests|app|bin|scripts)/[a-zA-Z0-9_./-]+\.[a-z]+' 2>/dev/null || true)
  
  local stale_paths=()
  if [ -n "$paths" ]; then
    while IFS= read -r path; do
      if [ ! -e "$target_dir/$path" ] && [ ! -e "$path" ]; then
        stale_paths+=("$path")
      fi
    done <<< "$paths"
  fi
  
  if [ ${#stale_paths[@]} -gt 0 ]; then
    echo "⚠️  Potentially stale paths found:"
    for path in "${stale_paths[@]}"; do
      echo "   - $path (not found)"
    done
    ((warnings++))
  else
    echo "✓ No obviously stale paths detected"
  fi
  
  # Check for common anti-patterns
  echo ""
  echo "Checking for anti-patterns..."
  
  # Check for vague platitudes
  local platitudes=("write clean code" "follow best practices" "keep it simple" "don't repeat yourself" "write good code")
  local found_platitudes=()
  for phrase in "${platitudes[@]}"; do
    if grep -qi "$phrase" "$agents_file" 2>/dev/null; then
      found_platitudes+=("$phrase")
    fi
  done
  
  if [ ${#found_platitudes[@]} -gt 0 ]; then
    echo "⚠️  Vague platitudes found (not actionable):"
    for phrase in "${found_platitudes[@]}"; do
      echo "   - \"$phrase\""
    done
    ((warnings++))
  else
    echo "✓ No vague platitudes found"
  fi
  
  # Check for "always" / "never" (potential contradictions)
  local absolutes
  absolutes=$(grep -iE "^\s*[-*]?\s*(always|never)\s+" "$agents_file" 2>/dev/null | head -5 || true)
  if [ -n "$absolutes" ]; then
    echo "⚠️  Absolute statements found (may cause contradictions):"
    echo "$absolutes" | head -3 | sed 's/^/   /'
    if [ "$(echo "$absolutes" | wc -l)" -gt 3 ]; then
      echo "   ... ($(echo "$absolutes" | wc -l) more)"
    fi
    ((warnings++))
  fi
  
  # Check for file structure documentation
  if grep -qiE "(directory structure|folder structure|file structure|project structure)" "$agents_file" 2>/dev/null; then
    echo "⚠️  File structure documentation found - this goes stale quickly"
    ((warnings++))
  fi
  
  # Summary
  echo ""
  echo "=== Summary ==="
  if [ $issues -eq 0 ] && [ $warnings -eq 0 ]; then
    echo "✓ All checks passed!"
  else
    echo "Issues: $issues, Warnings: $warnings"
    if [ $issues -gt 0 ]; then
      echo "Run './bin/irf agentsmd fix' to attempt auto-fixes"
    fi
  fi
}

agentsmd_fix() {
  local target_dir="${1:-$(pwd)}"
  local agents_file="$target_dir/AGENTS.md"
  
  echo "=== AGENTS.md Auto-Fix ==="
  echo ""
  
  if [ ! -f "$agents_file" ]; then
    echo "❌ AGENTS.md not found at: $agents_file"
    exit 1
  fi
  
  # Create backup
  local backup="$agents_file.backup.$(date +%Y%m%d%H%M%S)"
  cp "$agents_file" "$backup"
  echo "✓ Backup created: $backup"
  echo ""
  
  local fixes=0
  
  # Fix 1: Add package manager if missing
  if ! grep -qiE "(package manager|uv|poetry|pip|npm|pnpm|yarn)" "$agents_file"; then
    local pm
    pm=$(agentsmd_detect_package_manager "$target_dir")
    if [ "$pm" != "unknown" ]; then
      echo "Adding package manager ($pm)..."
      # Insert after the first heading
      sed -i.bak "1,/^# /{ /^# /a\\
\\
## Package Manager\\
\\
This project uses \`$pm\`.\\

}" "$agents_file" 2>/dev/null || true
      rm -f "$agents_file.bak"
      ((fixes++))
    fi
  fi
  
  # Fix 2: Remove trailing whitespace
  if sed -i.bak 's/[[:space:]]*$//' "$agents_file" 2>/dev/null; then
    if ! diff -q "$agents_file" "$agents_file.bak" >/dev/null 2>&1; then
      echo "✓ Removed trailing whitespace"
      ((fixes++))
    fi
    rm -f "$agents_file.bak"
  fi
  
  # Fix 3: Ensure single newline at end of file
  if [ -s "$agents_file" ]; then
    if [ "$(tail -c 1 "$agents_file" | wc -l)" -eq 0 ]; then
      echo "" >> "$agents_file"
      echo "✓ Added trailing newline"
      ((fixes++))
    fi
  fi
  
  echo ""
  if [ $fixes -eq 0 ]; then
    echo "No auto-fixes applied."
  else
    echo "Applied $fixes fix(es)."
  fi
  echo ""
  echo "Review changes with: git diff $agents_file"
}

agentsmd_cmd() {
  local subcmd="${1:-}"
  shift || true
  
  case "$subcmd" in
    init)
      agentsmd_init "$@"
      ;;
    status)
      agentsmd_status "$@"
      ;;
    validate)
      agentsmd_validate "$@"
      ;;
    fix)
      agentsmd_fix "$@"
      ;;
    ""|help|--help|-h)
      agentsmd_usage
      ;;
    *)
      echo "Unknown agentsmd subcommand: $subcmd" >&2
      agentsmd_usage
      exit 1
      ;;
  esac
}

backlog_ls() {
  local topic="${1:-}"
  local python_bin=""
  if command -v python3 >/dev/null 2>&1; then
    python_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    python_bin="python"
  else
    echo "Python not found; cannot list backlogs." >&2
    exit 1
  fi

  local ignore_project="false"
  if [ "$IS_GLOBAL" = true ]; then
    ignore_project="true"
  fi

  local args=("$CONFIG_HELPER" knowledge-dir --base "$TARGET_BASE")
  if [ "$ignore_project" = "true" ]; then
    args+=(--ignore-project)
  fi

  local knowledge_dir
  knowledge_dir=$("$python_bin" "${args[@]}")

  KNOWLEDGE_DIR="$knowledge_dir" TOPIC="$topic" \
    "$python_bin" - <<'PY'
import os
from pathlib import Path

topic_input = os.environ.get("TOPIC", "").strip()
knowledge_dir = os.environ.get("KNOWLEDGE_DIR", "").strip()

if not knowledge_dir:
    print("Knowledge directory not resolved.")
    raise SystemExit(1)

knowledge_path = Path(knowledge_dir).expanduser()
topics_dir = knowledge_path / "topics"

if not topics_dir.exists():
    print(f"No topics directory found: {topics_dir}")
    raise SystemExit(0)


def list_topics():
    topics = []
    for p in sorted(topics_dir.iterdir()):
        if not p.is_dir():
            continue
        if p.name.startswith("seed-") or p.name.startswith("baseline-") or p.name.startswith("plan-"):
            topics.append(p)
    return topics


def parse_backlog(path: Path):
    if not path.exists():
        return []
    rows = []
    for line in path.read_text(encoding="utf-8").splitlines():
        if not line.strip().startswith("|"):
            continue
        cells = [c.strip() for c in line.strip().strip("|").split("|")]
        if not cells:
            continue
        if cells[0].lower() == "id":
            continue
        if set(cells[0]) == {"-"}:
            continue
        if len(cells) < 2:
            continue
        rows.append(cells)
    return rows


def topic_type(name: str):
    if name.startswith("seed-"):
        return "seed"
    if name.startswith("baseline-"):
        return "baseline"
    if name.startswith("plan-"):
        return "plan"
    return "topic"


def ticket_summary(rows):
    ids = [r[0] for r in rows if r]
    if not ids:
        return "0"
    if len(ids) <= 3:
        return f"{len(ids)} ({', '.join(ids)})"
    return f"{len(ids)} ({', '.join(ids[:3])}, …)"


def resolve_topic(arg: str):
    if not arg:
        return None
    candidate = Path(arg).expanduser()
    if candidate.exists():
        return candidate
    if not candidate.is_absolute():
        rel = Path.cwd() / candidate
        if rel.exists():
            return rel
    return topics_dir / arg


topics = []
if topic_input:
    topic_path = resolve_topic(topic_input)
    if not topic_path.exists():
        available = [p.name for p in list_topics()]
        print(f"Topic not found: {topic_input}")
        if available:
            print("Available topics:")
            for name in available:
                print(f"- {name}")
        raise SystemExit(1)
    topics = [topic_path]
else:
    topics = list_topics()

if not topics:
    print(f"No seed/baseline/plan topics found in {topics_dir}")
    raise SystemExit(0)

if len(topics) == 1:
    topic = topics[0]
    backlog_path = topic / "backlog.md"
    rows = parse_backlog(backlog_path)
    print(f"Topic: {topic.name} ({topic_type(topic.name)})")
    if backlog_path.exists():
        print(f"Backlog: yes ({len(rows)} tickets)")
        print("")
        print(f"# Backlog: {topic.name}")
        print("| ID | Title | Est. Hours |")
        print("|----|-------|------------|")
        for row in rows:
            est = row[2] if len(row) > 2 else ""
            print(f"| {row[0]} | {row[1]} | {est} |")
    else:
        print("Backlog: no (unticketed)")
        print(f"Run: /irf-backlog {topic.name}")
else:
    print("| Topic | Type | Backlog | Tickets |")
    print("|-------|------|---------|---------|")
    for topic in topics:
        backlog_path = topic / "backlog.md"
        rows = parse_backlog(backlog_path)
        backlog_status = "yes" if backlog_path.exists() else "no"
        tickets = ticket_summary(rows) if backlog_path.exists() else "0"
        print(f"| {topic.name} | {topic_type(topic.name)} | {backlog_status} | {tickets} |")
PY
}

sync_models() {
  local python_cmd=()
  if resolve_python_cmd; then
    python_cmd=("${PYTHON_CMD[@]}")
  else
    echo "Python not found; cannot sync models." >&2
    exit 1
  fi

  local ignore_project="false"
  if [ "$IS_GLOBAL" = true ]; then
    ignore_project="true"
  fi

  echo "Syncing models from meta-model configuration..."
  "${python_cmd[@]}" "$CONFIG_HELPER" sync-models --base "$TARGET_BASE" ${ignore_project:+--ignore-project}
}

case "$COMMAND" in
  setup)
    echo "Ticketflow setup"
    if [ -z "$TARGET_BASE" ]; then
      read -r -p "Install globally? (Y/n) " yn
      case "$yn" in
        [Nn]*)
          read -r -p "Project path (default: current dir): " project_path
          project_path="${project_path:-$(pwd)}"
          TARGET_BASE="$project_path/.pi"
          SCOPE_FLAG="-l"
          IS_GLOBAL=false
          ;;
        *)
          TARGET_BASE="$HOME/.pi/agent"
          SCOPE_FLAG=""
          IS_GLOBAL=true
          ;;
      esac
    fi

    read -r -p "Install required Pi extensions (subagents, model-switch, prompt-template-model)? (Y/n) " yn
    install_deps=true
    case "$yn" in [Nn]*) install_deps=false ;; esac

    read -r -p "Install optional Pi extensions (review-loop, mcp-adapter)? (y/N) " yn
    install_optional=false
    case "$yn" in [Yy]*) install_optional=true ;; esac

    read -r -p "Configure MCP servers? (y/N) " yn
    configure_mcp=false
    case "$yn" in [Yy]*) configure_mcp=true ;; esac

    install_files
    install_extensions "$install_deps" "$install_optional"

    if [ "$configure_mcp" = true ]; then
      read -r -p "ZAI API key (required for ZAI servers, blank to skip): " zai_key
      read -r -p "Context7 API key (optional): " ctx7_key
      read -r -p "Exa API key (optional): " exa_key
      zai_key="${zai_key:-${ZAI_API_KEY:-}}"
      ctx7_key="${ctx7_key:-${CONTEXT7_API_KEY:-}}"
      exa_key="${exa_key:-${EXA_API_KEY:-}}"
      configure_mcp "$zai_key" "$ctx7_key" "$exa_key"
    fi
    ;;
  sync)
    sync_models
    ;;
  doctor)
    doctor
    ;;
  backlog-ls)
    if [ "${#ARGS[@]}" -gt 1 ]; then
      echo "Too many arguments for backlog-ls" >&2
      exit 1
    fi
    backlog_ls "${ARGS[0]:-}"
    ;;
  track)
    if [ "${#ARGS[@]}" -eq 0 ]; then
      track_file ""
    elif [ "${#ARGS[@]}" -eq 1 ]; then
      track_file "${ARGS[0]}"
    else
      echo "Too many arguments for track" >&2
      exit 1
    fi
    ;;
  ralph)
    ralph_cmd "${ARGS[@]}"
    ;;
  agentsmd)
    agentsmd_cmd "${ARGS[@]}"
    ;;
  *)
    usage
    exit 1
    ;;
esac
